(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{743:function(s,_,v){"use strict";v.r(_);var t=v(5),a=Object(t.a)({},(function(){var s=this,_=s.$createElement,v=s._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"分布式存储之hash取余算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分布式存储之hash取余算法"}},[s._v("#")]),s._v(" 分布式存储之hash取余算法")]),s._v(" "),v("p",[s._v("[toc]")]),s._v(" "),v("blockquote",[v("p",[s._v("cluster(集群)模式-docker版哈希槽分区进行亿级数据存储")])]),s._v(" "),v("p",[v("strong",[s._v("1~2亿条甚至更多数据需要缓存，请问如何设计这个存储案例")])]),s._v(" "),v("blockquote",[v("p",[s._v("使用普通关系型数据库百分百不可能实现，肯定是分布式存储，用redis如何落地？或者是mongoDB")])]),s._v(" "),v("h3",{attrs:{id:"_1-hash取余分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-hash取余分区"}},[s._v("#")]),s._v(" 1. hash取余分区")]),s._v(" "),v("p",[v("strong",[s._v("2亿条记录就是2亿条k,v，我们单机不行就必须要分布式多机，假如有3台机器构成一个集群，用户每次读写操作都是根据公式，hash（key)%N个机器台数，计算出hash值，用来决定数据映射到哪个节点上。")])]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("缺点：简单粗暴，起到负载均衡和分而治之")])]),s._v(" "),v("li",[v("strong",[s._v("缺点：某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重启洗牌")])])]),s._v(" "),v("h3",{attrs:{id:"_2-一致性hash算法分区"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-一致性hash算法分区"}},[s._v("#")]),s._v(" 2. 一致性hash算法分区")]),s._v(" "),v("p",[v("strong",[s._v("目的就是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数就不ok了")])]),s._v(" "),v("h5",{attrs:{id:"步骤"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#步骤"}},[s._v("#")]),s._v(" 步骤：")]),s._v(" "),v("ol",[v("li",[s._v("算法构建一致性哈希环\n"),v("ul",[v("li",[s._v("hash函数产生hash值，所有hash值构成一个全量集，这个集合可以成为hash空间")]),s._v(" "),v("li",[s._v("一致性hash算法就是将整个hash空间组织成一个虚拟的圆环")]),s._v(" "),v("li",[s._v("将各个服务器使用hash进行一次hash，具体可以选择服务器的IP或者主机名作为关键字映射")])])]),s._v(" "),v("li",[s._v("服务器IP结点映射")]),s._v(" "),v("li",[s._v("key落到服务器的落键规则")])]),s._v(" "),v("p",[v("img",{attrs:{src:"https://s2.loli.net/2022/05/11/WC3KuE2olbVgmOU.png",alt:"image-20220511224423420"}})]),s._v(" "),v("ul",[v("li",[v("p",[v("strong",[s._v("优点")])]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("一致性hash算法的容错性")])]),s._v(" "),v("li",[v("strong",[s._v("一致性hash算法的扩展性")])])])]),s._v(" "),v("li",[v("p",[v("strong",[s._v("缺点")])]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("一致性hash算法的数据倾斜问题")])])]),s._v(" "),v("blockquote",[v("p",[s._v("当结点太少非常容易导致结点分布不均匀")])])])]),s._v(" "),v("h3",{attrs:{id:"_3-哈希槽分区算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-哈希槽分区算法"}},[s._v("#")]),s._v(" 3. 哈希槽分区算法")]),s._v(" "),v("blockquote",[v("p",[s._v("这个是大厂非常常见的算法，解决了数据倾斜问题")])]),s._v(" "),v("p",[s._v("哈希槽实质就是一个数组，数据[0,2^14-1]形成hash slot空间")]),s._v(" "),v("p",[s._v("redis cluster使用的是hash slot算法，有固定的16384个hash slot，slot是槽的概念，有点类似memcached的slot，就理解为数据管理和迁移的基本单位吧。")]),s._v(" "),v("p",[v("strong",[s._v("redis cluster算是真正服务端的分布式缓存系统，不像memcached和2.0的redis需要在客户端进行负载均衡。")])]),s._v(" "),v("p",[v("strong",[s._v("算法:")])]),s._v(" "),v("p",[s._v("对每个 key 计算 CRC16 值，然后对 16384 取模，可以获取 key 对应的 hash slot。")]),s._v(" "),v("p",[v("strong",[s._v("数据分区")])]),s._v(" "),v("p",[s._v("Redis Cluster 采用"),v("strong",[s._v("虚拟槽分区")]),s._v("，所有的"),v("strong",[s._v("键")]),s._v("根据"),v("strong",[s._v("哈希函数")]),s._v("映射到 0~16383 （redis默认是16384个槽）整数槽内，计算公式：slot = CRC16（key）& 16384。每个节点负责维护一部分槽以及槽所映射的"),v("strong",[s._v("键值数据")]),s._v("，如图所示：")]),s._v(" "),v("blockquote",[v("p",[s._v("redis集群并没有使用一致性hash而是引入了哈希槽的概念，redis集群有16384个hash槽，每个key通过CRC16校验后对16384取模来决定放哪个槽，集群中每一个结点负责一部分槽，但为什么hash槽的数量是16384呢？")]),s._v(" "),v("p",[s._v("CRC16产生65535位")])]),s._v(" "),v("p",[v("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/11772383-cef761c010b2db72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/782/format/webp",alt:"img"}})]),s._v(" "),v("p",[v("strong",[s._v("举个例子")])]),s._v(" "),v("p",[v("img",{attrs:{src:"https:////upload-images.jianshu.io/upload_images/11772383-d3adce37a8763257.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/874/format/webp",alt:"img"}}),s._v("\n当前集群有 5 个节点，每个节点平均大约负责 3276 个"),v("strong",[s._v("槽")]),s._v("。由于采用"),v("strong",[s._v("高质量")]),s._v("的"),v("strong",[s._v("哈希算法")]),s._v("，每个槽所映射的数据通常比较"),v("strong",[s._v("均匀")]),s._v("，将数据平均划分到 5 个节点进行"),v("strong",[s._v("数据分区")]),s._v("。Redis Cluster 就是采用"),v("strong",[s._v("虚拟槽分区")]),s._v("。")]),s._v(" "),v("p",[v("strong",[s._v("节点1")]),s._v("： 包含 0 到 3276 号哈希槽。")]),s._v(" "),v("p",[v("strong",[s._v("节点2")]),s._v("：包含 3277 到 6553 号哈希槽。")]),s._v(" "),v("p",[v("strong",[s._v("节点3")]),s._v("：包含 6554 到 9830 号哈希槽。")]),s._v(" "),v("p",[v("strong",[s._v("节点4")]),s._v("：包含 9831 到 13107 号哈希槽。")]),s._v(" "),v("p",[v("strong",[s._v("节点5")]),s._v("：包含 13108 到 16383 号哈希槽。")]),s._v(" "),v("p",[s._v("所以hash slot的好处是可以像磁盘分区一样自由分配槽位，在配置文件里可以指定，也可以让redis自己选择分配，结果均匀。")]),s._v(" "),v("p",[s._v("这种结构很容易"),v("strong",[s._v("添加")]),s._v("或者"),v("strong",[s._v("删除")]),s._v("节点。如果"),v("strong",[s._v("增加")]),s._v("一个节点 6，就需要从节点 1 ~ 5 获得部分"),v("strong",[s._v("槽")]),s._v("分配到节点 6 上。如果想"),v("strong",[s._v("移除")]),s._v("节点 1，需要将节点 1 中的"),v("strong",[s._v("槽")]),s._v("移到节点 2 ~ 5 上，然后将"),v("strong",[s._v("没有任何槽")]),s._v("的节点 1 从集群中"),v("strong",[s._v("移除")]),s._v("即可。")]),s._v(" "),v("p",[s._v("由于从一个节点将"),v("strong",[s._v("哈希槽")]),s._v("移动到另一个节点并不会"),v("strong",[s._v("停止服务")]),s._v("，所以无论"),v("strong",[s._v("添加删除")]),s._v("或者"),v("strong",[s._v("改变")]),s._v("某个节点的"),v("strong",[s._v("哈希槽的数量")]),s._v("都不会造成"),v("strong",[s._v("集群不可用")]),s._v("的状态.")]),s._v(" "),v("h2",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[s._v("#")])]),s._v(" "),v("h4",{attrs:{id:"缓存的key-hash结果是和slot绑定的-而不是和服务器节点绑定-所以节点的更替只需要迁移slot即可平滑过渡。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存的key-hash结果是和slot绑定的-而不是和服务器节点绑定-所以节点的更替只需要迁移slot即可平滑过渡。"}},[s._v("#")]),s._v(" "),v("strong",[s._v("缓存的key hash结果是和slot绑定的，而不是和服务器节点绑定，所以节点的更替只需要迁移slot即可平滑过渡。")])]),s._v(" "),v("h2",{attrs:{id:"但是redis分片技术也有功能限制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#但是redis分片技术也有功能限制"}},[s._v("#")]),s._v(" 但是redis分片技术也有功能限制：")]),s._v(" "),v("p",[s._v("笔者遇到过的一些限制主要就是以下几点：")]),s._v(" "),v("p",[s._v("1.对于pipeline批量操作，只能路由到一个片区，压力相对大")]),s._v(" "),v("p",[s._v("2.hmset() map结构也是只能路由到一个片区，是根据大key进行hash，即使有很多个field。")]),s._v(" "),v("p",[s._v("3.事务，不同片区无法在同一个事务中")])])}),[],!1,null,null,null);_.default=a.exports}}]);